package Group3.CourseApp.Service.ServiceImpl;

import Group3.CourseApp.Service.CustomerService;
import Group3.CourseApp.Service.ProductService;
import Group3.CourseApp.Service.TransactionService;
import Group3.CourseApp.Service.UserService;

import Group3.CourseApp.constant.PaymentMethod;
import Group3.CourseApp.constant.TransactionStatus;
import Group3.CourseApp.dto.request.TransactionDetailRequest;
import Group3.CourseApp.dto.request.TransactionRequest;
import Group3.CourseApp.dto.response.GetAllTransactionResponse;
import Group3.CourseApp.dto.response.ProductReportResponse;
import Group3.CourseApp.dto.response.TransactionReportResponse;
import Group3.CourseApp.dto.response.TransactionResponse;
import Group3.CourseApp.entity.*;
import Group3.CourseApp.exception.CustomException;
import Group3.CourseApp.exception.ErrorCode;
import Group3.CourseApp.mapper.TransactionMapper;
import Group3.CourseApp.repository.TransactionDetailRepository;
import Group3.CourseApp.repository.TransactionRepository;
import Group3.CourseApp.security.JwtUtils;
import com.lowagie.text.*;
import com.lowagie.text.pdf.PdfPTable;
import com.lowagie.text.pdf.PdfWriter;

import com.midtrans.httpclient.error.MidtransError;
import com.midtrans.service.MidtransSnapApi;
import jakarta.persistence.criteria.*;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;



import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.Files;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class TransactionServiceImpl implements TransactionService {

    private final TransactionRepository transactionRepository;
    private final MidtransSnapApi snapApi;
    private final TransactionDetailRepository transactionDetailRepository;
    private final ProductService productService;
    private final CustomerService customerService;
    private final UserService userService;
    private final JwtUtils jwtUtils;
    private final String uploadDir = System.getProperty("user.home") + "/Documents/uploads";

    public void saveFile(MultipartFile file) throws IOException {
        // Pastikan direktori ada
        Path uploadPath = Paths.get(uploadDir);
        if (!Files.exists(uploadPath)) {
            Files.createDirectories(uploadPath);
        }

        // Simpan file
        Path filePath = uploadPath.resolve("ini bukti berubah 1" + file.getOriginalFilename());
        Files.write(filePath, file.getBytes());

        Path filePath2 = uploadPath.resolve("ini bukti berubah 2" + file.getOriginalFilename());
        Files.write(filePath2, file.getBytes());
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public TransactionResponse createTransaction(TransactionRequest transactionRequest) {
        Customer customer = customerService.findCustomerById(transactionRequest.getCustomerId());

        Transaction transaction = Transaction.builder()
                .transactionTime(LocalDateTime.now())
                .customer(customer)
                .paymentStatus(TransactionStatus.NOT_PAID)
                .build();

        double netAmountPaid = 0;
        double totalTaxPaid = 0;
        double totalAmountPaid = 0;

        for (TransactionDetailRequest detailRequest : transactionRequest.getDetails()) {
            Product product = productService.findProductById(detailRequest.getProductId());
            Double netPrice = product.getPrice() * detailRequest.getQuantity();
            Double taxAmount = netPrice * product.getTaxes().stream().mapToInt(Tax -> Tax.getRate()).sum() / 100;
            Double totalPrice = netPrice + taxAmount;


            TransactionDetail transactionDetail = TransactionDetail.builder()
                    .product(product)
                    .quantity(detailRequest.getQuantity())
                    .transaction(transaction)
                    .netPrice(netPrice)
                    .taxAmount(taxAmount)
                    .totalPrice(totalPrice)
                    .build();

            transaction.getDetails().add(transactionDetail);

            netAmountPaid += netPrice;
            totalTaxPaid += taxAmount;
            totalAmountPaid += totalPrice;
        }

        transaction.setNetAmountPaid(netAmountPaid);
        transaction.setTotalTaxPaid(totalTaxPaid);
        transaction.setTotalAmountPaid(totalAmountPaid);

        String token = jwtUtils.getTokenFromHeader();
        jwtUtils.validateJwtToken(token);
        String nameCreator = jwtUtils.getUsernameFromJwtToken(token);

        transaction.setCreatedBy(nameCreator);
        transactionRepository.save(transaction);

        return TransactionMapper.toTransactionResponse(transaction);
    }

    @Override
    public TransactionResponse findById(String id) {
        Transaction transaction = findTransactionById(id);
        return TransactionMapper.toTransactionResponse(transaction);
    }

    @Override
    public void deleteTransactionById(String id) {
        Transaction transaction = findTransactionById(id);
        transactionRepository.delete(transaction);
    }

    @Override
    public TransactionResponse cancelTransaction(String id) {
        Transaction transaction = findTransactionById(id);
        transaction.setPaymentStatus(TransactionStatus.CANCELLED);
        transactionRepository.save(transaction);
        return TransactionMapper.toTransactionResponse(transaction);
    }

    @Override
    public TransactionResponse completeTransaction(String id, PaymentMethod paymentMethod) {
        Transaction transaction = findTransactionById(id);
        transaction.setPaymentMethod(paymentMethod);
        transaction.setPaymentStatus(TransactionStatus.PAID);
        transactionRepository.save(transaction);
        return TransactionMapper.toTransactionResponse(transaction);
    }

    @Override
    public Page<GetAllTransactionResponse> getAllTransactionsDate(
            LocalDate startDate,
            LocalDate endDate,
            String customerName,
            List<TransactionStatus> paymentStatuses,
            List<PaymentMethod> paymentMethods,
            String createdBy,
            int page,
            int size,
            String sortField,
            String sortDirection
    ) {
        Sort sort = Sort.by(sortDirection.equalsIgnoreCase("asc") ? Sort.Direction.ASC : Sort.Direction.DESC, sortField);

        Pageable pageable = PageRequest.of(page, size, sort);

        Specification<Transaction> spec = TransactionSpecification.filterTransactions(
                startDate,
                endDate,
                customerName,
                paymentStatuses,
                paymentMethods,
                createdBy
        );

        Page<Transaction> transactionPage = transactionRepository.findAll(spec, pageable);

        Page<GetAllTransactionResponse> transactionResponsePage = transactionPage.map(TransactionMapper::toGetAllTransactionResponse);
        return transactionResponsePage;
    }

    @Override
    public TransactionReportResponse getTotalAmountPaidByCustomerBetweenDates(String customerId, LocalDate startDate, LocalDate endDate) {
        LocalDateTime startDateTime = startDate.atStartOfDay();
        LocalDateTime endDateTime = endDate.atTime(23, 59, 59);

        Specification<Transaction> spec = TransactionSpecification.filterByCustomerAndDateRange(customerId, startDateTime, endDateTime);

        List<Transaction> transactions = transactionRepository.findAll(spec);
        double totalAmount = transactions.stream()
                .mapToDouble(Transaction::getTotalAmountPaid)
                .sum();

        String customerName = transactions.isEmpty() ? "No Transaction" : transactions.get(0).getCustomer().getName();

        return TransactionReportResponse.builder()
                .name(customerName)
                .amount(totalAmount)
                .build();
    }

    @Override
    public TransactionReportResponse financialReportCustomer(LocalDate startDate, LocalDate endDate) {
        LocalDateTime startDateTime = startDate.atStartOfDay();
        LocalDateTime endDateTime = endDate.atTime(23, 59, 59);

        String token = jwtUtils.getTokenFromHeader();
        jwtUtils.validateJwtToken(token);
        String username = jwtUtils.getUsernameFromJwtToken(token);
        User user = userService.findByUsername(username).orElseThrow(() -> new CustomException(ErrorCode.USER_NOT_FOUND));
        Customer customer = customerService.findCustomerById(user.getUserId());

        Specification<Transaction> spec = TransactionSpecification.filterByCustomerAndDateRange(customer.getId(), startDateTime, endDateTime);

        List<Transaction> transactions = transactionRepository.findAll(spec);
        double totalAmount = transactions.stream()
                .mapToDouble(Transaction::getTotalAmountPaid)
                .sum();

        String customerName = transactions.isEmpty() ? "Unknown" : transactions.get(0).getCustomer().getName();

        return TransactionReportResponse.builder()
                .name(customerName)
                .amount(totalAmount)
                .build();
    }

    @Override
    public Map<String, String> createSnapToken(String transactionId) throws MidtransError {
        Transaction transaction = findTransactionById(transactionId);

        Map<String, Object> params = new HashMap<>();
        Map<String, Object> txnDetails = new HashMap<>();
        List<Map<String, Object>> itemDetails = new ArrayList<>();

        double calculatedGrossAmount = 0.0;

        // === Loop untuk mengambil detail transaksi dan menghitung total harga ===
        for (TransactionDetail detail : transaction.getDetails()) {
            Map<String, Object> item = new HashMap<>();
            item.put("id", detail.getProduct().getId());
            item.put("price", detail.getNetPrice());
            item.put("quantity", detail.getQuantity());
            item.put("name", detail.getProduct().getName());
            itemDetails.add(item);

            // Menambahkan harga total setiap item (price * quantity) ke gross amount
            calculatedGrossAmount += detail.getNetPrice() * detail.getQuantity();
        }

        // === Set nilai gross_amount sesuai hasil perhitungan dari itemDetails ===
        txnDetails.put("order_id", transactionId.toString());
        txnDetails.put("gross_amount", calculatedGrossAmount); // <--- Ini sudah diperbaiki
        params.put("transaction_details", txnDetails);

        // === Langkah Tambahan: Menambahkan Customer Details ===
        Customer customer = transaction.getCustomer();
        Map<String, Object> customerDetails = new HashMap<>();
        customerDetails.put("first_name", customer.getName());
        params.put("customer_details", customerDetails);

        params.put("item_details", itemDetails);

        // Mendapatkan token Snap
        String token = snapApi.createTransactionToken(params);
        // Mendapatkan redirect URL (jika ingin menggunakan redirect flow)
        String redirectUrl = snapApi.createTransactionRedirectUrl(params);

        Map<String, String> result = new HashMap<>();
        result.put("token", token);
        result.put("redirect_url", redirectUrl);
        return result;
    }


    public byte[] generateCustomerReportPdf(LocalDate startDate, LocalDate endDate) {
        ByteArrayOutputStream out = new ByteArrayOutputStream();

        // Ambil data transaksi untuk customer saat ini
        TransactionReportResponse report = financialReportCustomer(startDate, endDate);

        try {

            Document document = new Document();
            PdfWriter.getInstance(document, out);
            document.open();

            // Tambahkan judul
            Font titleFont = FontFactory.getFont(FontFactory.HELVETICA_BOLD, 16);
            Paragraph title = new Paragraph("Customer Transaction Report", titleFont);
            title.setAlignment(Element.ALIGN_CENTER);
            document.add(title);
            document.add(Chunk.NEWLINE);

            // Tambahkan rentang tanggal
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd-MM-yyyy");
            Paragraph period = new Paragraph("Period: " + startDate.format(formatter) + " to " + endDate.format(formatter));
            document.add(period);
            document.add(Chunk.NEWLINE);

            // Tambahkan informasi customer
            PdfPTable table = new PdfPTable(2);
            table.setWidthPercentage(100);
            table.setSpacingBefore(10f);
            table.setSpacingAfter(10f);
            table.setWidths(new float[]{3, 2});

            table.addCell("Customer Name");
            table.addCell(report.getName());

            table.addCell("Total Amount Paid");
            table.addCell(String.format("Rp%,.2f", report.getAmount()));

            document.add(table);
            document.close();
        } catch (Exception e) {
            throw new RuntimeException("Failed to generate PDF", e);
        }

        return out.toByteArray();
    }

    public List<TransactionReportResponse> getTotalAmountPaidPerProduct() {
        return transactionDetailRepository.getTotalAmountPaidPerProduct();
    }


    public Transaction findTransactionById(String id) {
        return transactionRepository.findById(id).orElseThrow(() -> new CustomException(ErrorCode.TRANSACTION_NOT_FOUND));
    }

    public class TransactionSpecification {

        public static Specification<Transaction> filterTransactions(LocalDate startDate, LocalDate endDate, String customerName, List<TransactionStatus> statuses, List<PaymentMethod> methods, String createdBy) {
            return (Root<Transaction> root, CriteriaQuery<?> query, CriteriaBuilder cb) -> {
                Predicate predicate = cb.conjunction();

                if (startDate != null && endDate != null) {
                    predicate = cb.and(predicate, cb.between(root.get("transactionTime"), startDate, endDate));
                }

                if (customerName != null && !customerName.isEmpty()) {
                    Join<Object, Object> customer = root.join("customer");
                    predicate = cb.and(predicate, cb.like(cb.lower(customer.get("name")), "%" + customerName.toLowerCase() + "%"));
                }

                if (statuses != null && !statuses.isEmpty()) {
                    predicate = cb.and(predicate, root.get("paymentStatus").in(statuses));
                }

                if (methods != null && !methods.isEmpty()) {
                    predicate = cb.and(predicate, root.get("paymentMethod").in(methods));
                }

                if (createdBy != null && !createdBy.isEmpty()) {
                    predicate = cb.and(predicate, cb.equal(root.get("createdBy"), createdBy));
                }

                return predicate;
            };
        }
        public static Specification<Transaction> filterByCustomerAndDateRange(String customerId, LocalDateTime startDate, LocalDateTime endDate) {
            return (root, query, cb) -> {
                Predicate predicate = cb.conjunction();

                if (customerId != null) {
                    predicate = cb.and(predicate, cb.equal(root.get("customer").get("id"), customerId));
                }

                if (startDate != null && endDate != null) {
                    predicate = cb.and(predicate, cb.between(root.get("transactionTime"), startDate, endDate));
                }

                return predicate;
            };
        }
    }

}
